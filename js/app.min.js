(() => {
    "use strict";

    const uniqueArray = arr => arr.filter((item, index) => arr.indexOf(item) === index);

    class ScrollWatcher {
        constructor(config) {
            this.config = Object.assign({ logging: true }, config);
            this.observer = null;
            if (!document.documentElement.classList.contains("watcher")) {
                this.initializeScrollWatcher();
            }
        }

        initializeScrollWatcher() {
            document.documentElement.classList.add("watcher");
            this.watchElements(document.querySelectorAll("[data-watch]"));
        }

        watchElements(elements) {
            if (elements.length) {
                this.log(`Watching ${elements.length} elements...`);
                const uniqueConfigs = uniqueArray(Array.from(elements).map(el => {
                    return `${el.dataset.watchRoot || null}|${el.dataset.watchMargin || "0px"}|${el.dataset.watchThreshold || 0}`;
                }));

                uniqueConfigs.forEach(configStr => {
                    const [root, margin, threshold] = configStr.split("|");
                    const relatedElements = Array.from(elements).filter(el => {
                        return el.dataset.watchRoot === root &&
                               el.dataset.watchMargin === margin &&
                               el.dataset.watchThreshold === threshold;
                    });
                    const observerConfig = this.getObserverConfig({ root, margin, threshold });
                    this.initializeObserver(relatedElements, observerConfig);
                });
            } else {
                this.log("No elements to watch.");
            }
        }

        getObserverConfig({ root, margin, threshold }) {
            const config = {};
            config.root = document.querySelector(root) || null;

            if (root !== 'null' && !config.root) {
                this.log(`Root element ${root} not found.`);
            }

            config.rootMargin = margin;

            if (margin.indexOf("px") < 0 && margin.indexOf("%") < 0) {
                this.log("Margin must be specified in px or %.");
                return null;
            }

            config.threshold = threshold === 'prx'
                ? Array.from({ length: 201 }, (_, i) => i / 200) // 0.0 to 1.0
                : threshold.split(",");

            return config;
        }

        initializeObserver(elements, config) {
            this.createObserver(config);
            elements.forEach(el => this.observer.observe(el));
        }

        createObserver(config) {
            this.observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => this.handleIntersection(entry));
            }, config);
        }

        handleIntersection(entry) {
            const target = entry.target;
            if (entry.isIntersecting) {
                if (!target.classList.contains("_watcher-view")) {
                    target.classList.add("_watcher-view");
                    this.log(`Element is in view: ${target.classList}`);
                }
            } else {
                if (target.classList.contains("_watcher-view")) {
                    target.classList.remove("_watcher-view");
                    this.log(`Element is out of view: ${target.classList}`);
                }
            }

            if (target.hasAttribute("data-watch-once") && entry.isIntersecting) {
                this.observer.unobserve(target);
            }

            document.dispatchEvent(new CustomEvent("watcherCallback", { detail: { entry } }));
        }

        log(message) {
            if (this.config.logging) {
                setTimeout(() => {
                    window.FLS && console.log(message);
                }, 0);
            }
        }
    }

    const canvas = document.querySelector("#scene");
    const ctx = canvas.getContext("2d");
    const particles = [];
    let particleCount = 0;
    let mousePos = { x: 0, y: 0 };
    let particleSize = 1;
    const colors = ["#468966", "#FFF0A5", "#FFB03B", "#B64926", "#8E2800"];
    const inputField = document.querySelector("#copy");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    class Particle {
        constructor(targetX, targetY) {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.dest = { x: targetX, y: targetY };
            this.radius = Math.random() * 3 + 2;
            this.velocityX = 120 * (Math.random() - 0.5);
            this.velocityY = 120 * (Math.random() - 0.5);
            this.accX = 0;
            this.accY = 0;
            this.friction = Math.random() * 0.001 + 0.94;
            this.color = colors[Math.floor(Math.random() * colors.length)];
        }

        render() {
            this.accX = (this.dest.x - this.x) / 800;
            this.accY = (this.dest.y - this.y) / 800;
            this.velocityX += this.accX;
            this.velocityY += this.accY;
            this.velocityX *= this.friction;
            this.velocityY *= this.friction;
            this.x += this.velocityX;
            this.y += this.velocityY;

            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
            ctx.fill();

            const distX = this.x - mousePos.x;
            const distY = this.y - mousePos.y;
            if (Math.sqrt(distX * distX + distY * distY) < 50 * particleSize) {
                this.accX = (this.x - mousePos.x) / 10;
                this.accY = (this.y - mousePos.y) / 20;
                this.velocityX += this.accX;
                this.velocityY += this.accY;
            }
        }
    }

    const updateCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${canvas.width / 10}px sans-serif`;
        ctx.textAlign = "center";
        ctx.fillText(inputField.value, canvas.width / 2, canvas.height / 2);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = "screen";
        particles.length = 0;

        for (let x = 0; x < canvas.width; x += Math.round(canvas.width / 250)) {
            for (let y = 0; y < canvas.height; y += Math.round(canvas.width / 250)) {
                if (imageData[4 * (x + y * canvas.width) + 3] > 250) {
                    particles.push(new Particle(x, y));
                }
            }
        }
        particleCount = particles.length;
    };

    inputField.addEventListener("keyup", updateCanvas);
    window.addEventListener("resize", updateCanvas);
    window.addEventListener("mousemove", (event) => {
        mousePos.x = event.clientX;
        mousePos.y = event.clientY;
    });
    window.addEventListener("touchmove", (event) => {
        if (event.touches.length > 0) {
            mousePos.x = event.touches[0].clientX;
            mousePos.y = event.touches[0].clientY;
        }
    });
    window.addEventListener("click", () => {
        particleSize = (particleSize + 1) % 6;
    });
    window.addEventListener("touchend", () => {
        mousePos.x = -9999;
        mousePos.y = -9999;
    });

    updateCanvas();

    const animateParticles = (time) => {
        requestAnimationFrame(animateParticles);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < particleCount; i++) {
            particles[i].render();
        }
    };

    requestAnimationFrame(animateParticles);

    // Check for webp support
    const checkWebpSupport = (callback) => {
        const img = new Image();
        img.onload = () => callback(img.height === 2);
        img.onerror = () => callback(false);
        img.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
    };

    checkWebpSupport((isSupported) => {
        const className = isSupported ? "webp" : "no-webp";
        document.documentElement.classList.add(className);
    });

    // Initialize scroll watcher
    const watcher = new ScrollWatcher();
})();
